<style>
html,
body {
  height: 100%;
}
body {
  overflow: hidden;
  margin: 0;
  background-color: #000;
}
canvas {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translate(-50%, 0);
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
<script src="https://unpkg.com/three-bas@2.0.2/dist/bas.min.js"></script>

<script src="js/threePost.js"></script>

<script>
const TEXTURE_SRC_BEFORE = 'https://images.unsplash.com/photo-1457369900526-e7606baa133b?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=800&fit=max&s=96647cd4038299342a15cd2bd177075f' // https://unsplash.com/photos/dcp4hnQY-z0
const TEXTURE_SRC_AFTER = 'https://images.unsplash.com/photo-1456947700819-d91abdf38117?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=800&fit=max&s=96647cd4038299342a15cd2bd177075f' // https://unsplash.com/photos/weuWmzv7xnU
const PREFAB = {
  WIDTH: 1,
  HEIGHT: 1
}

function init (textureBefore, textureAfter) {
  const image = textureBefore.image
  const width = image.width
  const height = image.height
  const intervalX = width / PREFAB.WIDTH
  const intervalY = height / PREFAB.HEIGHT

  const root = new THREERoot({
    cameraPosition: [0, 0, width * 2.5],
    aspect: 0.6 / 1
  })

  const prefab = new THREE.PlaneGeometry(PREFAB.WIDTH, PREFAB.HEIGHT)
  const geometry = new BAS.PrefabBufferGeometry(prefab, intervalX * intervalY)
  const aPosition = geometry.createAttribute('aPosition', 4)

  let i = 0
  for (let x = 0; x < intervalX; x++) {
    for (let y = 0; y < intervalY; y++) {
      geometry.setPrefabData(aPosition, i++, [
        x * PREFAB.WIDTH - (width / 2),
        y * PREFAB.HEIGHT - (height / 2),
        0,
        Math.random() // random coefficient
      ])
    }
  }

  textureBefore.minFilter = THREE.LinearFilter
  textureAfter.minFilter = THREE.LinearFilter

  const material = new BAS.BasicAnimationMaterial({
    side: THREE.DoubleSide,
    vertexColors: THREE.VertexColors,
    uniforms: {
      uTime: { type: 'f', value: 0 },
      uSize: { type: 'vf2', value: [width, height] },
      mapBefore: { type: 't', value: textureBefore },
      mapAfter: { type: 't', value: textureAfter },
    },
    vertexFunctions: [
      BAS.ShaderChunk['ease_cubic_in_out'],
      BAS.ShaderChunk['ease_cubic_in'],
    ],
    vertexParameters: [
      'uniform float uTime;',
      'uniform vec2 uSize;',
      'uniform sampler2D mapBefore;',
      'uniform sampler2D mapAfter;',
      'attribute vec4 aPosition;',
      'const float interval = 10.;',
      'const float delay = 1.5;',
      'const float speed = 80.;',
      'const float minWeight = 0.3;',
      'const float fallSpeed = 4.;',
      'const float xSpeed = 0.02;',
      'const float spreadPosition = 0.03;',
    ],
    vertexInit: [
      'vec2 texelCoord = (aPosition.xy + uSize / 2.) / uSize;',
      'vec4 texelBefore = texture2D(mapBefore, texelCoord);',
      'vec4 texelAfter = texture2D(mapAfter, texelCoord);',
      'float bottom = aPosition.y - uSize.y * 2.;',
      'float tTime = mod(uTime / 100., interval + delay) - delay;',
      'float progress = max(tTime, 0.);',
      'float nProgress = progress / interval;',
      'float move = progress * speed;',
      'float weightBefore = pow(1. - texelBefore.r * texelBefore.g * texelBefore.b, 2.) * (1. - minWeight) + minWeight;',
      'float weightAfter = pow(1. - texelAfter.r * texelAfter.g * texelAfter.b, 2.) * (1. - minWeight) + minWeight;',
      'float order = pow(abs(aPosition.x) / (uSize.x * 0.5), 2.) * 40.;',
      'float fall = max(-aPosition.y - uSize.y / 2. + move - order, 0.) * (aPosition.w * 0.2 + 1.) * (0.3 + nProgress) * fallSpeed;',
      'float y = aPosition.y - fall * mix(weightBefore, weightAfter, easeCubicIn(min(fall, -bottom) / -bottom)) - move + order * smoothstep(0., 0.5, tTime);',
      'float offsetY = easeCubicInOut(1. - max(-tTime, 0.) / delay) * uSize.y * 1.2;',
    ],
    vertexPosition: [
      'transformed.x += aPosition.x / (1. + fall * xSpeed * max(1. - max(-y + (bottom * (1. - spreadPosition)), 0.) / (-bottom * spreadPosition), 0.));',
      //  / abs(aPosition.x / (uSize.x / 2.))
      'transformed.y += max(y, bottom) + offsetY;',
      'transformed.z += aPosition.z;',
    ],
    vertexColor: [
      'vColor = mix(texelBefore.rgb, texelAfter.rgb, smoothstep(-uSize.y / 2., bottom, y));',
    ],
  })
  material.uniforms['mapBefore'].value.needsUpdate = true
  material.uniforms['mapAfter'].value.needsUpdate = true

  const mesh = new THREE.Mesh(geometry, material)
  mesh.frustumCulled = false

  root.add(mesh)

  let time = 0

  const postShader = new THREE.ShaderPass({
    uniforms: {
      'tDiffuse': { type: 't', value: null },
      'uTime': { type: 'f', value: time },
    },
    vertexShader: `
      varying vec2 vUv;

      void main () {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float uTime;
      varying vec2 vUv;
      const float interval = 10.;
      const float delay = 1.5;
      const float size = 0.03;
      const float halfSize = size * 0.5;
      const float n = size * 4.;
      const float brightness = 600.;
      const float speed = 0.006;

      vec4 getMosaicColor (vec2 coord) {
        return texture2D(tDiffuse, coord);
        // vec4 mosaicColor = vec4(0.);
        // for (float x = 0.; x <= size; x += size * 0.2) {
        //   for (float y = 0.; y <= size; y += size * 0.2) {
        //     mosaicColor += texture2D(tDiffuse, vec2(coord.x + x, coord.y + y));
        //   }
        // }
        // return mosaicColor;
      }

      float lengthN (vec2 v, float n) {
        vec2 tmp = pow(abs(v), vec2(n));
        return pow(tmp.x + tmp.y, size / n);
      }

      float random (vec2 st) {
        return fract(sin(dot(st, vec2(12.9898, 4.1414))) * 43758.5453);
      }

      void main () {
        vec4 texel = texture2D(tDiffuse, vUv);
        vec2 mosaicCoord = floor(vUv / size) * size + halfSize;
        vec4 mosaicColor = getMosaicColor(mosaicCoord);
        vec2 p = mod(vUv, size) - halfSize;
        float tTime = mod(uTime / 100., interval + delay) - delay;
        float mosaicBrightness = mosaicColor.r * mosaicColor.g * mosaicColor.b;
        float isBlink = step(0.0005, mosaicBrightness);
        // float isBlink = step(0.02, mosaicBrightness / 36.);
        float l = (1. - clamp(lengthN(p, n), 0., 1.)) * isBlink * step(vUv.y, 0.5) * step(0., tTime);
        float time = uTime * speed;
        float n = random(mosaicCoord) * 10.;
        float blink = l * brightness * max(sin(time + n) - 0.99, 0.);
        gl_FragColor = texel + vec4(vec3(blink), 1.);
      }
    `,
  })
  root.initPostProcessing([
    postShader,
    new THREE.BloomPass(1.1, 25, 3.1, 256),
    new THREE.ShaderPass(THREE.CopyShader)
  ])

  root.addUpdateCallback(() => {
    time++
    material.uniforms['uTime'].value = time
    postShader.uniforms['uTime'].value = time
  })

  root.start()
}

let textureBefore, textureAfter
function onLoad () {
  (textureBefore && textureAfter) && init(textureBefore, textureAfter)
}
new THREE.TextureLoader().load(TEXTURE_SRC_BEFORE, texture => {
  textureBefore = texture
  onLoad()
})
new THREE.TextureLoader().load(TEXTURE_SRC_AFTER, texture => {
  textureAfter = texture
  onLoad()
})

// --------------------
// Three.js Wrapper
// forked from https://github.com/zadvorsky/three.bas/blob/86931253240abadf68b7c62edb934b994693ed4a/examples/_js/root.js
// --------------------
class THREERoot {
  constructor (params) {
    // defaults
    params = Object.assign({
      container: document.body,
      fov: 45,
      zNear: 1,
      zFar: 10000,
      cameraPosition: [0, 0, 30],
      createCameraControls: false,
      autoStart: true,
      pixelRatio: window.devicePixelRatio,
      antialias: (window.devicePixelRatio === 1),
      alpha: false,
      clearColor: 0x000000
    }, params)

    // maps and arrays
    this.updateCallbacks = []
    this.resizeCallbacks = []
    this.objects = {}

    // renderer
    this.renderer = new THREE.WebGLRenderer({
      antialias: params.antialias,
      alpha: params.alpha
    })
    this.renderer.setPixelRatio(params.pixelRatio)
    this.renderer.setClearColor(params.clearColor)
    this.canvas = this.renderer.domElement

    // container
    this.container = (typeof params.container === 'string') ? document.querySelector(params.container) : params.container
    this.container.appendChild(this.canvas)

    this.aspect = params.aspect
    this.setSize()

    // camera
    this.camera = new THREE.PerspectiveCamera(
      params.fov,
      this.width / this.height,
      params.zNear,
      params.zFar
    )
    this.camera.position.set(...params.cameraPosition)

    // scene
    this.scene = new THREE.Scene()

    // resize handling
    this.resize()
    window.addEventListener('resize', () => {
      this.resize()
    })

    // tick / update / render
    params.autoStart && this.tick()

    // optional camera controls
    params.createCameraControls && this.createOrbitControls()

    // pointer
    this.raycaster = new THREE.Raycaster()
    this.pointer = new THREE.Vector2()
  }

  setSize () {
    if (this.aspect) {
      if (this.container.clientWidth / this.container.clientHeight > this.aspect) {
        this.width = this.container.clientHeight * this.aspect
        this.height = this.container.clientHeight
      } else {
        this.width = this.container.clientWidth
        this.height = this.container.clientWidth / this.aspect
      }
    } else {
      this.width = this.container.clientWidth
      this.height = this.container.clientHeight
    }
  }

  createOrbitControls () {
    if (!THREE.TrackballControls) {
      console.error('TrackballControls.js file is not loaded.')
      return
    }

    this.controls = new THREE.TrackballControls(this.camera, this.canvas)
    this.addUpdateCallback(() => { this.controls.update() })
  }

  start () {
    this.tick()
  }

  stop () {
    cancelAnimationFrame(this.animationFrameId)
  }

  addUpdateCallback (callback) {
    this.updateCallbacks.push(callback)
  }

  addResizeCallback (callback) {
    this.resizeCallbacks.push(callback)
  }

  add (object, key) {
    key && (this.objects[key] = object)
    this.scene.add(object)
  }

  addTo (object, parentKey, key) {
    key && (this.objects[key] = object)
    this.get(parentKey).add(object)
  }

  get (key) {
    return this.objects[key]
  }

  remove (o) {
    let object

    if (typeof o === 'string') {
      object = this.objects[o]
    } else {
      object = o
    }

    if (object) {
      object.parent.remove(object)
      delete this.objects[o]
    }
  }

  tick (time) {
    this.update(time)
    this.render()
    this.animationFrameId = requestAnimationFrame(time => { this.tick(time) })
  }

  update (time) {
    this.updateCallbacks.forEach(callback => { callback(time) })
  }

  render () {
    this.renderer.render(this.scene, this.camera)
  }

  resize () {
    this.container.style.width = ''
    this.container.style.height = ''
    this.setSize()

    this.camera.aspect = this.width / this.height
    this.camera.updateProjectionMatrix()

    this.renderer.setSize(this.width, this.height)
    this.resizeCallbacks.forEach(callback => { callback() })
  }

  initPostProcessing (passes) {
    const size = this.renderer.getSize()
    const pixelRatio = this.renderer.getPixelRatio()
    size.width *= pixelRatio
    size.height *= pixelRatio

    const composer = this.composer = new THREE.EffectComposer(this.renderer, new THREE.WebGLRenderTarget(size.width, size.height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      stencilBuffer: false
    }))

    const renderPass = new THREE.RenderPass(this.scene, this.camera)
    composer.addPass(renderPass)

    for (let i = 0; i < passes.length; i++) {
      const pass = passes[i]
      pass.renderToScreen = (i === passes.length - 1)
      composer.addPass(pass)
    }

    this.renderer.autoClear = false
    this.render = () => {
      this.renderer.clear()
      composer.render()
    }

    this.addResizeCallback(() => {
      composer.setSize(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio)
    })
  }

  checkPointer ({ x, y }, meshs, handler, nohandler) {
    this.pointer.x = (x / this.canvas.clientWidth) * 2 - 1
    this.pointer.y = -(y / this.canvas.clientHeight) * 2 + 1

    this.raycaster.setFromCamera(this.pointer, this.camera)
    const intersects = this.raycaster.intersectObjects(meshs)

    if (intersects.length > 0) {
      handler(intersects[0].object)

      return true
    } else {
      nohandler && nohandler()

      return false
    }
  }
}
</script>

<body>
</body>
